import Mathlib.Order.Hom.Basic
import Data.Probability
import Data.KFinset
import Data.Table
import Math.DomainTheory
import Dice.Ast
import Data.HList
import Dice.Termination
import Dice.Instantiation
import Math.DomainTheory
import Mathlib.Algebra.Order.Pointwise
import Mathlib.Order.CompleteLattice

open Value AExpr Expr Program
open BigOperators

------------------------------
-- SEMANTICS OF EXPRESSIONS --
------------------------------
section
set_option hygiene false
local notation:max " ‚ü¶ " v " ‚üß·µ• " => semValue v
def semValue (v1: Value œÑ): ùîª(œÑ) :=
  fun v => if v == v1 then 1 else 0
end
notation:max "‚ü¶" v "‚üß·µ•" => semValue v

section
set_option hygiene false
local notation:max T "‚ü¶" e "‚üß " => semExpr T e
local notation:max T "‚ü¶" e "‚üß(" v ") " => semExpr T e v
def semExpr (T: Table œÅ) : Expr œÅ [] œÑ -> ùîª(œÑ)
  | Atomic (AValue v1) =>
    ‚ü¶v1‚üß·µ•

  | Fst (AValue $ VPair v1 _) =>
    ‚ü¶v1‚üß·µ•

  | Snd (AValue $ VPair _ v2) =>
    ‚ü¶v2‚üß·µ•

  | Pair (AValue v1) (AValue v2) =>
    ‚ü¶VPair v1 v2‚üß·µ•

  | Flip Œ∏ => Œª
    | VTrue  => Œ∏.prob
    | VFalse => Œ∏.invProb

  | Observe (AValue v1) => Œª
    | VTrue  => ‚ü¶v1‚üß·µ• <| VTrue
    | VFalse => 0

  | Ifte (AValue vg) e1 e2 =>
    match vg with
    | VTrue => T‚ü¶e1‚üß
    | VFalse => T‚ü¶e2‚üß

  | Let e1 e2  =>
    (‚àë v', (T‚ü¶e1‚üß(v')) * (T‚ü¶e2[‚Ü¶ v'::·µ¢[]·µ¢]‚üß))

  | Call f as =>
    (T.get f) (as.map AExpr.value)

  termination_by e => size e
  decreasing_by all_goals (simp_wf; (conv => rhs; unfold size); linarith)
end
notation:max T "‚ü¶" e "‚üß(" v ")" => semExpr T e v
notation:max T "‚ü¶" e "‚üß" => semExpr T e

@[simp] theorem semExpr_atomic : T‚ü¶Atomic (AValue v1)‚üß = ‚ü¶v1‚üß·µ• := by unfold semExpr; rfl
@[simp] theorem semExpr_fst : T‚ü¶Fst (AValue (VPair v1 v2))‚üß = ‚ü¶v1‚üß·µ• := by unfold semExpr; rfl
@[simp] theorem semExpr_snd : T‚ü¶Snd (AValue (VPair v1 v2))‚üß = ‚ü¶v2‚üß·µ• := by unfold semExpr; rfl
@[simp] theorem semExpr_pair : T‚ü¶Pair (AValue v1) (AValue v2)‚üß = ‚ü¶VPair v1 v2‚üß·µ• := by unfold semExpr; rfl
@[simp] theorem semExpr_flip : T‚ü¶Flip Œ∏‚üß = Œª | VTrue => Œ∏.prob | VFalse => Œ∏.invProb := by unfold semExpr; rfl
@[simp] theorem semExpr_observe : T‚ü¶Observe (AValue v1)‚üß = Œª | VTrue => ‚ü¶v1‚üß·µ• <| VTrue | VFalse => 0 := by unfold semExpr; rfl
@[simp] theorem semExpr_ifte_true : T‚ü¶Ifte (AValue VTrue) e1 e2‚üß = T‚ü¶e1‚üß := by conv => lhs; unfold semExpr
@[simp] theorem semExpr_ifte_false : T‚ü¶Ifte (AValue VFalse) e1 e2‚üß = T‚ü¶e2‚üß := by conv => lhs; unfold semExpr
@[simp] theorem semExpr_let : T‚ü¶Let e1 e2‚üß = (‚àë v', (T‚ü¶e1‚üß(v')) * (T‚ü¶e2[‚Ü¶ v'::·µ¢[]·µ¢]‚üß)) := by conv => lhs; unfold semExpr
@[simp] theorem semExpr_call : T‚ü¶Call f as‚üß = (T.get f) (as.map AExpr.value) := by unfold semExpr; rfl

-- @[simp] theorem semProgramC'_simp : semProgramC' I e = semProgramC I []‚Çï e := by aesop
-- @[simp] theorem semProgramC_expr : semProgramC I T (PExpr e) = T‚ü¶e‚üß := by unfold semProgramC; rfl
-- @[simp] theorem semProgramC_func : semProgramC (Table.cons i is) T (PFunc e p) = semProgramC is (Table.cons i T) p := by aesop

def functionCharacteristic
  (f: Func œÅ œÄ œÑ) (T: Table œÅ)
  : (Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) -> (Value[œÄ]‚Çï ‚Üí ùîª(œÑ))
  := fun I vs => (@HList.cons _ _ (œÄ,œÑ) œÅ I T)‚ü¶f[‚Ü¶ inst'' vs]‚üß
notation "Œ¶[" T "," f "](" I ")" => functionCharacteristic f T I
notation "Œ¶[" T "," f "]" => functionCharacteristic f T

------------------------------------------
-- MONOTONICITY OF EXPRESSION SEMANTICS --
------------------------------------------

theorem semExpr_monotone_table
  (e: Expr œÅ œÄ œÑ) (S: Inst œÄ [])
  : Monotone (fun T => semExpr T (e[‚Ü¶ S]))
  := by
    induction e with
    | Atomic a1 => intro T1 T2 _; simp_all
    | Fst a1 => intro T1 T2 _; simp_all; cases (inst_aexpr_value S a1); simp_all;
    | Snd a1 => intro T1 T2 _; simp_all; cases (inst_aexpr_value S a1); simp_all;
    | Flip => intro T1 T2 _; simp_all
    | Observe a1 => intro T1 T2 _; simp_all
    | Pair a1 a2 => intro T1 T2 _; simp_all
    | Let e1 e2 ih1 ih2 =>
      intro T1 T2 hT v; simp_all; apply Finset.sum_le_sum
      intro i _; apply Probability.mul_le_mul' _ _ <;>
      simp_all [ih1 S hT i, ih2 (cons_inst (AValue i) S) hT v]
    | Call f as =>
      intro T1 T2 hT v; simp_all
      induction f
      . cases T1; cases T2; rw [Table.le_cons_ext] at hT; apply hT.left
      . cases T1; cases T2; rw [Table.le_cons_ext] at hT; simp_all
    | Ifte a1 e1 e2 ih1 ih2 =>
      intro T1 T2 hT v; simp_all; cases (inst_aexpr_value S a1) <;> aesop

theorem semExpr_monotone_invariant
  (e: Expr ((œÄ,œÑ)::œÅ) œÄ' œÑ') (T: Table œÅ) (S: Inst œÄ' [])
  : Monotone (fun I => (I ::‚Çï T)‚ü¶e[‚Ü¶ S]‚üß)
  := by
    intro I1 I2 hI;
    have TH : HList.cons' (œÄ,œÑ) I1 T ‚â§ HList.cons' (œÄ,œÑ) I2 T := by
      unfold_projs; unfold Table.le; simp_all
    intro v; have := semExpr_monotone_table e S TH v
    aesop

theorem functionCharacteristic_monotone
  {œÄ: [Ty]'} {œÑ: Ty} {œÅ: [Sig]'} (f: Func œÅ œÄ œÑ) (T: Table œÅ)
  : Monotone (Œ¶[T,f](¬∑))
  := by
    intro I1 I2 hM
    unfold functionCharacteristic;
    intro i v;
    simp_all
    apply semExpr_monotone_invariant _ _ _ hM

theorem functionCharacteristic_monotone'
  {œÄ: [Ty]'} {œÑ: Ty} {œÅ: [Sig]'} (f: Func œÅ œÄ œÑ)
  : Monotone (Œ¶[¬∑,f])
  := by
    intro I1 I2 hM
    unfold functionCharacteristic;
    intro i v;
    simp_all
    apply semExpr_monotone_table
    rw [Table.le_cons_ext]; simp_all

------

theorem semExpr_scott_table (e: Expr Œì œÄ œÑ) (S: Inst œÄ [])
  : ScottContinuous' (¬∑‚ü¶e[‚Ü¶ S]‚üß) := by
  intro T h cT
  induction e with
  | Atomic a => cases a <;> simp_all
  | Fst a => simp_all; cases (inst_aexpr_value S a); simp_all
  | Snd a => simp_all; cases (inst_aexpr_value S a); simp_all
  | Flip p => simp_all
  | Pair a1 a2 => simp_all
  | Observe a => simp_all
  | @Let Œì œÑ‚ÇÅ œÑ‚ÇÇ e1 e2 ih1 ih2 =>
    unfold inst_expr semExpr;
    simp_all; funext;
    let f := (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x))
    let g := (Œªx t => t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß)
    let fg := (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x) * t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß)
    have : ‚àÄb x y, x ‚â§ y ‚Üí fg b x ‚â§ fg b y := by
      intro b x y h1; apply SemiDistribution.pmul_le_pmul; repeat (apply semExpr_monotone_table; assumption)
    have := SemiDistribution.sSup_summation T (by aesop) cT (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x) * t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß) this (Finset.univ : Finset (Value œÑ‚ÇÅ))
    unfold Set.image; simp_all; rw [‚Üê this]
    have ‚ü®t, th‚ü© := h
    have t1: ‚àÄx, {x_1 | ‚àÉ x_2 ‚àà T, x_2‚ü¶e1[‚Ü¶ S]‚üß(x) * x_2‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß = x_1} = ((Œªy => f x y * g x y) '' T) := by aesop
    have : ‚àÄx, (Monotone fun t => t‚ü¶e1[‚Ü¶ S]‚üß(x)) := by intro x a b ab; simp_all; apply Pi.le_def.mp ?_ x; apply semExpr_monotone_table; assumption
    have t2 := fun x => SemiDistribution.sSup_cmul'' T h cT (f x) (this x) (g x) (by simp_all; apply semExpr_monotone_table)
    have t3: ‚àÄy, {x_1 | ‚àÉ t ‚àà T, t‚ü¶e1[‚Ü¶ S]‚üß(y) = x_1} = (f y '' T) := by aesop
    have t4: ‚àÄy, {x | ‚àÉ t ‚àà T, t‚ü¶e2[‚Ü¶ y::·µ¢S]‚üß = x} = (g y '' T) := by aesop
    conv in (‚àë b : Value œÑ‚ÇÅ, sSup {x | ‚àÉ x_1 ‚àà T, x_1‚ü¶e1[‚Ü¶ S]‚üß(b) * x_1‚ü¶e2[‚Ü¶ b::·µ¢S]‚üß = x}) =>
      enter [2,x]; rw [t1 x, t2 x]
    conv_rhs =>
      enter [2,x]; rw [‚Üê ih1 S, ‚Üê ih2 (x::·µ¢S), sSup_apply'];
    simp_all
  | Call f as =>
    unfold semExpr inst_expr;
    simp_all
    rw [‚Üê Table.sSup_apply, sSup_apply'];
    simp_all
    aesop; aesop
  | Ifte a e1 e2 =>
    simp_all; cases (inst_aexpr_value S a) <;> simp_all

theorem semExpr_coscott_table (e: Expr Œì œÄ œÑ) (S: Inst œÄ [])
  : CoScottContinuous' (¬∑‚ü¶e[‚Ü¶ S]‚üß) := by
  intro T h cT
  induction e with
  | Atomic a => cases a <;> simp_all
  | Fst a => simp_all; cases (inst_aexpr_value S a); simp_all
  | Snd a => simp_all; cases (inst_aexpr_value S a); simp_all
  | Flip p => simp_all
  | Pair a1 a2 => simp_all
  | Observe a => simp_all
  | @Let Œì œÑ‚ÇÅ œÑ‚ÇÇ e1 e2 ih1 ih2 =>
    unfold inst_expr semExpr;
    simp_all; funext;
    let f := (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x))
    let g := (Œªx t => t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß)
    let fg := (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x) * t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß)
    have : ‚àÄb x y, x ‚â§ y ‚Üí fg b x ‚â§ fg b y := by
      intro b x y h1; apply SemiDistribution.pmul_le_pmul; repeat (apply semExpr_monotone_table; assumption)
    have := SemiDistribution.sInf_summation T (by aesop) cT (Œªx t => t‚ü¶e1[‚Ü¶ S]‚üß(x) * t‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß) this (Finset.univ : Finset (Value œÑ‚ÇÅ))
    unfold Set.image; simp_all; rw [‚Üê this]
    have ‚ü®t, th‚ü© := h
    have t1: ‚àÄx, {x_1 | ‚àÉ x_2 ‚àà T, x_2‚ü¶e1[‚Ü¶ S]‚üß(x) * x_2‚ü¶e2[‚Ü¶ x::·µ¢S]‚üß = x_1} = ((Œªy => f x y * g x y) '' T) := by aesop
    have : ‚àÄx, (Monotone fun t => t‚ü¶e1[‚Ü¶ S]‚üß(x)) := by intro x a b ab; simp_all; apply Pi.le_def.mp ?_ x; apply semExpr_monotone_table; assumption
    have t2 := fun x => SemiDistribution.sInf_cmul'' T h cT (f x) (this x) (g x) (by simp_all; apply semExpr_monotone_table)
    have t3: ‚àÄy, {x_1 | ‚àÉ t ‚àà T, t‚ü¶e1[‚Ü¶ S]‚üß(y) = x_1} = (f y '' T) := by aesop
    have t4: ‚àÄy, {x | ‚àÉ t ‚àà T, t‚ü¶e2[‚Ü¶ y::·µ¢S]‚üß = x} = (g y '' T) := by aesop
    conv in (‚àë b : Value œÑ‚ÇÅ, sInf {x | ‚àÉ x_1 ‚àà T, x_1‚ü¶e1[‚Ü¶ S]‚üß(b) * x_1‚ü¶e2[‚Ü¶ b::·µ¢S]‚üß = x}) =>
      enter [2,x]; rw [t1 x, t2 x]
    conv_rhs =>
      enter [2,x]; rw [‚Üê ih1 S, ‚Üê ih2 (x::·µ¢S), sInf_apply']
    simp_all
  | Call f as =>
    unfold semExpr inst_expr;
    simp_all
    rw [‚Üê Table.sInf_apply, sInf_apply'];
    simp_all
    aesop; aesop
  | Ifte a e1 e2 =>
    simp_all; cases (inst_aexpr_value S a) <;> simp_all

theorem semExpr_monotone_invariant'
  (e: Expr ((œÄ,œÑ)::œÅ) œÄ' œÑ') (T: Table œÅ) (S: Inst œÄ' [])
  : Monotone (fun I => (I ::‚Çï T)‚ü¶e[‚Ü¶ S]‚üß)
  := by
    intro I1 I2 hI;
    let T1 := @HList.cons _ _ (œÄ,œÑ) œÅ I1 T
    let T2 := @HList.cons _ _ (œÄ,œÑ) œÅ I2 T
    have TH : T1 ‚â§ T2 := by
      unfold_projs; unfold Table.le; cases T1; cases T2;
      simp_all
    intro v; have := semExpr_monotone_table e S TH v
    simp_all

theorem functionCharacteristic_scott
  {œÄ: [Ty]'} {œÑ: Ty} {œÅ: [Sig]'} (f: Func œÅ œÄ œÑ) (T: Table œÅ)
  : ScottContinuous' Œ¶[T,f]
  := by
    intro I h cI
    have ‚ü®i, ih‚ü© := h
    unfold functionCharacteristic;
    let IT := {@HList.cons _ _ (œÄ,œÑ) œÅ i T | i ‚àà I}
    have : {HList.head it | it ‚àà IT} = I := by aesop
    have : {HList.tail it | it ‚àà IT} = {T} := by unfold HList.tail; aesop
    have : sSup {T} = T := by aesop
    have : ((fun I vs => (I :: T)‚ü¶f[‚Ü¶ inst'' vs]‚üß) '' I) = {Œª vs => t‚ü¶f[‚Ü¶ inst'' vs]‚üß | t ‚àà IT} := by aesop
    rw [this]
    have : IsChain (¬∑ ‚â§ ¬∑) IT := by
      intro a aA b bB aneb; simp_all; cases a; cases b; simp_all; aesop
    have : IT.Nonempty := by existsi (HList.cons' (œÄ,œÑ) i T); simp_all; existsi i; aesop
    have x := fun vs => (semExpr_scott_table f (inst'' vs) this (by aesop)).symm
    simp_all
    have : @HList.cons _ _ (œÄ,œÑ) œÅ (sSup I) T = sSup IT := by rw [Table.sSup_cons_ext IT]; aesop
    rw [this]; clear this
    conv_rhs => ext vs; rw [x vs]
    funext a;
    rw [sSup_apply'];
    simp_all
    have : {x | ‚àÉt ‚àà IT, (fun vs => t‚ü¶f[‚Ü¶ inst'' vs]‚üß) a = x } = {t‚ü¶f[‚Ü¶ inst'' a]‚üß | t ‚àà IT} := by
      ext val; simp_all
    unfold Set.image; simp_all;

theorem functionCharacteristic_coscott
  {œÄ: [Ty]'} {œÑ: Ty} {œÅ: [Sig]'} (f: Func œÅ œÄ œÑ) (T: Table œÅ)
  : CoScottContinuous' Œ¶[T,f]
  := by
    intro I h cI
    have ‚ü®i, ih‚ü© := h
    unfold functionCharacteristic;
    let IT := {@HList.cons _ _ (œÄ,œÑ) œÅ i T | i ‚àà I}
    have : {HList.head it | it ‚àà IT} = I := by aesop
    have : {HList.tail it | it ‚àà IT} = {T} := by unfold HList.tail; aesop
    have : sInf {T} = T := by aesop
    have : ((fun I vs => (I :: T)‚ü¶f[‚Ü¶ inst'' vs]‚üß) '' I) = {Œª vs => t‚ü¶f[‚Ü¶ inst'' vs]‚üß | t ‚àà IT} := by aesop
    rw [this]
    have : IsChain (¬∑ ‚â§ ¬∑) IT := by
      intro a aA b bB aneb; simp_all; cases a; cases b; simp_all; aesop
    have : IT.Nonempty := by existsi (HList.cons' (œÄ,œÑ) i T); simp_all; existsi i; aesop
    have x := fun vs => (semExpr_coscott_table f (inst'' vs) this (by aesop)).symm
    simp_all
    have : @HList.cons _ _ (œÄ,œÑ) œÅ (sInf I) T = sInf IT := by rw [Table.sInf_cons_ext IT]; aesop
    rw [this]; clear this
    conv_rhs => ext vs; rw [x vs]
    funext a;
    rw [sInf_apply'];
    simp_all
    have : {x | ‚àÉt ‚àà IT, (fun vs => t‚ü¶f[‚Ü¶ inst'' vs]‚üß) a = x } = {t‚ü¶f[‚Ü¶ inst'' a]‚üß | t ‚àà IT} := by
      ext val; simp_all
    unfold Set.image; simp_all;

------

noncomputable def semFunc
  {œÄ: List Ty} {œÑ: Ty} {œÅ: [Sig]'}
  (T: Table œÅ) (f: Func œÅ œÄ œÑ)
  : (Value[œÄ]‚Çï -> ùîª(œÑ))
  := OrderHom.lfp ‚ü®Œ¶[T,f], functionCharacteristic_monotone f T‚ü©

noncomputable def semProgram {œÅ': [Sig]'} (T: Table œÅ): Program œÑ œÅ œÅ' -> ùîª(œÑ)
  | PExpr e => semExpr T e
  | PFunc f e =>
      let T' := HList.cons (semFunc T f) T
      semProgram T' e

noncomputable def semProgram' : Program œÑ [] œÅ -> ùîª(œÑ) :=
  semProgram HList.nil

theorem semFunc_monotone_table
  : Monotone (fun T => semFunc T f)
  := by
    intro t1 t2 h
    simp_all; unfold semFunc; rw [‚Üê lowerb, ‚Üê lowerb]
    apply sSup_le; intro b bB; simp_all
    have ‚ü®bB1, bB2‚ü© := bB
    rw [‚Üê bB2]; clear bB2
    have : (Œ¶[t2,f]^[bB1] ‚ä•) ‚àà {x | ‚àÉ n, Œ¶[t2,f]^[n] ‚ä• = x} := by aesop
    apply le_sSup_of_le this
    induction' bB1 with n ih
    . simp_all
    . simp_all [Function.iterate_succ_apply'];
      calc
        Œ¶[t1,f](Œ¶[t1,f]^[n] ‚ä•)
        _ ‚â§ Œ¶[t2,f](Œ¶[t1,f]^[n] ‚ä•) := (functionCharacteristic_monotone' f h) (Œ¶[t1,f]^[n] ‚ä•)
        _ ‚â§ Œ¶[t2,f](Œ¶[t2,f]^[n] ‚ä•) := (functionCharacteristic_monotone f t2 ih)
    exact functionCharacteristic_scott f t2
    exact functionCharacteristic_scott f t1

theorem semProgram_monotone_table
  : Monotone (fun T => semProgram T p)
  := by
    induction p with
    | @PFunc _ œÄ' œÑ' _ f p ih =>
      unfold semProgram; simp_all;
      intro t1 t2 tlet; simp_all
      let t1' := (HList.cons' (œÄ',œÑ') (semFunc t1 f) t1)
      let t2' := (HList.cons' (œÄ',œÑ') (semFunc t2 f) t2)
      have := @ih t1' t2'
      simp at this
      have : t1' ‚â§ t2' := by rw [Table.le_cons_ext]; simp_all; apply semFunc_monotone_table tlet
      have := ih this
      simp_all
    | PExpr e =>
      have : e = e[‚Ü¶ id_inst] := by simp
      rw [this]
      unfold semProgram; exact semExpr_monotone_table e id_inst

--------------------------
-- COMPUTABLE EXTENSION --
--------------------------

def semProgramC (I: Table œÅ') (T: Table œÅ) : Program œÑ œÅ œÅ' -> ùîª(œÑ)
  | PExpr e => T‚ü¶e‚üß
  | PFunc _ p =>
    match I with
    | @HList.cons _ _ (œÄ,œÑ) _ i is =>
      let T': Table ((œÄ,œÑ)::œÅ) := i ::‚Çï T
      semProgramC is T' p

def semProgramC' (I: Table œÅ) : Program œÑ [] œÅ -> ùîª(œÑ) :=
  semProgramC I []‚Çï

def toFinset (f: ùîª(œÑ)): KFinset (Value œÑ) ‚Ñù :=
  ‚ü®Finset.univ, fun v => (f v : ‚Ñù)‚ü©

def normFact (f: ùîª(œÑ)): DReal :=
  ‚àë x in Finset.univ, (f x).val

def normProb (f: ùîª(œÑ)): ùîª(œÑ) :=
  fun x => (f x).divD (normFact f)

def SuperInvariant (I: Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) (T: Table œÅ) (f: Func œÅ œÄ œÑ)
  : Prop := functionCharacteristic f T I ‚â§ I

def LowerBound (I: Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) (T: Table œÅ) (f: Func œÅ œÄ œÑ)
  : Prop := I ‚â§ semFunc T f

def UpperBound (I: Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) (T: Table œÅ) (f: Func œÅ œÄ œÑ)
  : Prop := semFunc T f ‚â§ I

inductive FLInvariant {œÑ: Ty} : Program œÑ œÅ œÅ' -> Table œÅ -> Table œÅ' -> Type where
  | nil    : FLInvariant (PExpr e) T []
  | cons f : FLInvariant p (i ::‚Çï T) I -> LowerBound i T f
          -> FLInvariant (PFunc f (cast (by simp only [Prod.mk.eta]) p)) T (i ::‚Çï I)

inductive FUInvariant {œÑ: Ty} : Program œÑ œÅ œÅ' -> Table œÅ -> Table œÅ' -> Type where
  | nil    : FUInvariant (PExpr e) T []
  | cons f : FUInvariant p (i ::‚Çï T) I -> UpperBound i T f
          -> FUInvariant (PFunc f (cast (by simp only [Prod.mk.eta]) p)) T (i ::‚Çï I)

theorem semFunc_supI : Œ¶[T,f](I) ‚â§ I -> semFunc T f ‚â§ I := by
  intro h; apply OrderHom.lfp_le; simp_all

@[simp]
theorem semExpr_cast {h1: a = b} {h2: Expr a [] œÑ = Expr b [] œÑ} : semExpr (HList.cast T h1) (cast h2 e) = semExpr T e
  := by aesop

theorem semProgram_supB
  {I: Table œÅ'} {TC: Table œÅ} {TN: Table œÅ} {p: Program œÑ œÅ œÅ'}
  : FUInvariant p TC I -> TN ‚â§ TC -> semProgram TN p ‚â§ semProgramC I TC p := by
    induction p with
    | PExpr e =>
      intro _ h2;
      unfold semProgram semProgramC;
      rw [Pi.le_def]; intro v; rw [Probability.le_ext, DReal.le_ext]
      have := semExpr_monotone_table e id_inst h2 v
      simp at this; assumption
    | PFunc f p' ih =>
      rename_i œÅ œÄ œÑ œÅ'
      intro h1 h2;
      have : semProgram TN (PFunc f p') = semProgram (HList.cons' (œÄ,œÑ) (semFunc TN f) TN) p' := by
        (conv_lhs => unfold semProgram)
      cases' I with _ _ i is
      calc
        semProgram TN (PFunc f p')
        _ = semProgram (HList.cons' (œÄ,œÑ) (semFunc TN f) TN) p' := by conv_lhs => unfold semProgram
        _ ‚â§ semProgram (HList.cons' (œÄ,œÑ) i TN) p' := by
            cases' h1 with _ _ _ œÄœÑ E F p' i _ _ f' FUI UB
            unfold UpperBound at UB; simp_all;
            apply semProgram_monotone_table; rw [Table.le_cons_ext]
            have : semFunc TN f' ‚â§ semFunc TC f' := semFunc_monotone_table h2
            simp_all; exact le_trans this UB
        _ ‚â§ semProgramC is (HList.cons' (œÄ,œÑ) i TC) p' := by
            cases' h1 with _ _ _ œÄœÑ E F p' i _ _ f' FUI UB
            apply ih;
            . simp_all; exact FUI;
            . rw [Table.le_cons_ext]; simp_all;
        _ = semProgramC (HList.cons' (œÄ,œÑ) i is) TC (PFunc f p') := by
            conv_rhs => unfold semProgramC

theorem semProgram_lowB
  {I: Table œÅ'} {TC: Table œÅ} {TN: Table œÅ} {p: Program œÑ œÅ œÅ'}
  : FLInvariant p TC I -> TC ‚â§ TN -> semProgramC I TC p ‚â§ semProgram TN p := by
    induction p with
    | PExpr e =>
      intro _ h2;
      unfold semProgram semProgramC;
      rw [Pi.le_def]; intro v; rw [Probability.le_ext, DReal.le_ext]
      have := semExpr_monotone_table e id_inst h2 v
      simp at this; assumption
    | PFunc f p' ih =>
      rename_i œÅ œÄ œÑ œÅ'
      intro h1 h2;
      have : semProgram TN (PFunc f p') = semProgram (HList.cons' (œÄ,œÑ) (semFunc TN f) TN) p' := by
        (conv_lhs => unfold semProgram)
      cases' I with _ _ i is
      calc
        semProgramC (HList.cons' (œÄ,œÑ) i is) TC (PFunc f p')
        _ = semProgramC is (HList.cons' (œÄ,œÑ) i TC) p' := by
            conv_lhs => unfold semProgramC;
        _ ‚â§ semProgram (HList.cons' (œÄ,œÑ) i TN) p' := by
            cases' h1 with _ _ _ œÄœÑ E F p' i _ _ f' FUI LB
            apply ih;
            . simp_all; exact FUI;
            . rw [Table.le_cons_ext]; simp_all;
        _ ‚â§ semProgram (HList.cons' (œÄ,œÑ) (semFunc TN f) TN) p' := by
            cases' h1 with _ _ _ œÄœÑ E F p' i _ _ f' FUI LB
            unfold LowerBound at LB; simp_all;
            apply semProgram_monotone_table; rw [Table.le_cons_ext]
            have : semFunc TC f' ‚â§ semFunc TN f' := semFunc_monotone_table h2
            simp_all; exact le_trans LB this
        _ = semProgram TN (PFunc f p') := by conv_rhs => unfold semProgram

theorem semProgram_supB' {I: Table œÅ'} {p: Program œÑ [] œÅ'}
  : FUInvariant p [] I -> semProgram' p ‚â§ semProgramC' I p := by
    unfold semProgram' semProgramC';
    intro h; apply semProgram_supB; exact h; simp

theorem semProgram_lowB' {I: Table œÅ'} {p: Program œÑ [] œÅ'}
  : FLInvariant p [] I -> semProgramC' I p ‚â§ semProgram' p:= by
    unfold semProgram' semProgramC';
    intro h; apply semProgram_lowB; exact h; simp

theorem search_lowerbound (T: Table œÅ) (f: Func œÅ œÄ œÑ): Œ¶[T,f]^[n] 0 ‚â§ semFunc T f := by
  let cfun : (Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) ‚Üío (Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) := ‚ü®Œ¶[T,f], functionCharacteristic_monotone f T‚ü©
  have : Œ¶[T,f] = cfun.toFun := by rfl
  rw [this]
  unfold semFunc;
  apply lowerb' cfun (functionCharacteristic_scott f T)

theorem search_upperbound (T: Table œÅ) (f: Func œÅ œÄ œÑ): semFunc T f ‚â§ Œ¶[T,f]^[n] 1 := by
  let cfun : (Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) ‚Üío (Value[œÄ]‚Çï ‚Üí ùîª(œÑ)) := ‚ü®Œ¶[T,f], functionCharacteristic_monotone f T‚ü©
  have : Œ¶[T,f] = cfun.toFun := by rfl
  rw [this]
  unfold semFunc;
  have : OrderHom.lfp cfun ‚â§ OrderHom.gfp cfun := by
    have := OrderHom.isGreatest_gfp cfun
    have := OrderHom.isLeast_lfp cfun
    unfold IsGreatest IsLeast at *
    aesop
  apply le_trans this
  apply upperb' cfun (functionCharacteristic_coscott f T)
